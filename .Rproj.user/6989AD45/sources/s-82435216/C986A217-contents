## Skript slouží jako zásobárna důležitých funkcí pro stahování audia z ČRo2 a ČRo3

## FrK 2020-03-28 Created
## FrK 2020-11-07 Edited


# Načtení packagí
library(dplyr)
library(rvest)
library(httr)

# Funkce 'stahni.cetbu', která stáhne seriál nebo hru či povídku na základě paramtrů:
# 'autor' - autor díla ve formátu PrijmeniJ,
# 'dilo' - název díla ve formátu CamelStyleName,
# 'aimDir' - adresář, pro hry je '!!!Hry', pro seriály 'autor-dilo'
# 'dataUrl' - stránka na webu rozhlas.cz, kde je četba/dílo a
# 'stazene' - je to vektor čísel, která říkají jaké díly četby jsou stažené
# 'cislovat' - je to jen pro povídky - někdy jich je celá série od jednoho autora, a pak stojí za to si je očíslovat, ale default bude FALSE
stahni.cetbu =
  function(autor = NULL, dilo = NULL, aimDir = NULL, dataUrl = NULL, stazene = -1, cislovat = FALSE) {

    # Tvorba adresáře pro uložení souborů, pokud neexistuje
    dir = getwd()  # Pracovní adresář, kde jsou nakonec vnořené všechny četby
    outDir = file.path(dir, aimDir)
    if (!dir.exists(outDir)){ # Převzato ze Stack Overflow
      dir.create(outDir, recursive=TRUE)
      print(paste0("Adresář '",
                   outDir,
                   "' byl právě vytvořen.")
            )
    } else {
      # print(paste0("Adresář '", outDir, "' existuje, není třeba ho vytvářet."))
    }


    # Stáhneme si ze stránky základ pro adresy souborů *.mp3 a další potřebné údaje
    zaklad = read_html(dataUrl) %>%
      html_nodes(css = '.sm2-playlist-wrapper') %>%  # '.sm2-playlist-wrapper' doplněno, protože ve 'Čtenářském deníku' je každý díl ve svém vlastním playlistu
      html_nodes('li') %>%  # Tohle tu taky musi byt, jinak to nefunguje dobře
      html_nodes(css = '.sm2-wide')

    # Adresy
    cesty = zaklad %>% html_nodes(css = 'a') %>% html_attr('href')
    #print(length(cesty))

    # Čísla dílů
    dily = zaklad %>% html_attr('part')  # Máme štěstí, že to stáhne jen čísla stahovatelných dílů / povídek
    #print(dily[is.na(dily)])

    # Někde, např. u 'Čtenářského deníku', chybí atribut 'part', tedy číslo dílu nejde vytáhnout.
    # Musíme ho tedy doplnit sami. Zatím jsem narazil jen na četby, kde jsou všechny díly k dispozici,
    # tak to můžeme zkusit jednoduchým for-cyklem
    for (i in 1:length(cesty)) if (is.na(dily[i])) dily[i] = as.character(i)
    # Asi by šlo ve 'for' použít 'length(dily)', ale chci mít kontrolu, že vektory 'cesty' a 'dily' jsou stejně dlouhé.

    # Zkrácení vektoru s názvy, pokud již některé díly četby/ série povídek expirovaly
    if (aimDir != "!!!Hry" & length(dilo) > 1) dilo = dilo[dily %>% as.integer()]
    if (aimDir != "!!!Hry" & length(autor) > 1) autor = autor[dily %>% as.integer()]
    # Je důležité pořád držet i expirované názvy, aby nebyl bordel

    #print(dily)
    if (!is.na(dily[1])) for (i in 1:length(dily)) if (nchar(dily[i]) == 1) dily[i] = paste0("0", dily[i])
    # Kvůli abecednímu řazení dáme před jednociferná čísla dílů '0'

    # Sestavení jmen souborů pro uložení
    #print(dily)
    if (aimDir == "!!!Hry" | aimDir == "!!!Pohadky"| aimDir == "!!!Jine" | (aimDir == "!!!Povidky" & !cislovat)) {
      jmena = paste0(autor, '-', dilo, '.mp3') # Oprava pro pohádky a hry
    } else {
      jmena = paste0(autor, '-', dily, '-', dilo, '.mp3')
    }


    # Samotné stažení
    for (i in 1:length(cesty)) {
      #print(dily[i])
      if (!(as.integer(dily[i]) %in% stazene)) {
        if (file.exists(file.path(dir, aimDir, jmena[i]))) {
          print(paste0("Soubor '",
                       jmena[i],
                       "' v adresáři '",
                       aimDir,
                       "' už existuje."))
        } else {
          print(paste0("Stahuji: ", jmena[i], " ..."))
          GET(cesty[i], write_disk(file.path(dir, aimDir, jmena[i]), overwrite = TRUE))
          print(paste0("Soubor '",
                       jmena[i],
                       "' je uložen v adresáři '",
                       aimDir,
                       "'."))
        }
      } else {
        print(paste0("V objektu 'stazene' bylo specifikováno, aby se díl č. ",
                     dily[i],
                     " nestahoval."))
      }
    }
  }



## Patrikovo řešení stahování linků sjako funkce
# 'main_page' - je to stránka, kde jsou informace o aktuálních četbách, je třeba jí zadat ve formátu:
# 'https://vltava.rozhlas.cz/hry-a-cetba?page='
# 'pages' - kolik stran hluboko máme jít, obvykle stačí 3 strany, aby se obsáhl poslední týden,
#  kdy jsou četby ke stažení, proto je default nastaven na 3
stahni.cesty = function(main_page = NULL, pages = 3) {
  df = data.frame()
  zaklad = substr(main_page, 1, 25)  # Vyuziju toho, ze zaklad obou stranek je dlouhy 25 znaku, staci tedy brute force.

  for(i in 0:(pages - 1)){
    if (main_page == 'https://junior.rozhlas.cz/pribehy') {
      html = read_html(main_page)
    } else {
      html = read_html(paste0(main_page, i))
    }
    temp = data.frame(
      # Name=html %>% html_nodes("h3 a") %>% html_text(),
      # Někdy na Vltavě vynechají typ četby, a tak následující řádek nefunguje... Je těžké zjistit, kde to vypadne...
      # Typ=html %>% html_nodes(".tag span") %>% html_text(),  # Ale typ je důležitý pro orientaci v linkách, tak to stojí za to zkoušet.
      URL=paste0(zaklad, html %>% html_nodes(".button-play") %>% html_attr("href"))
    )
    df <- rbind(df, temp)
  }
  df #%>% as_tibble()  # Patrikovo 'as_tibble()' je elegantni, ale mně to nevyhovuje, protože to zkracuje cesty.
}


